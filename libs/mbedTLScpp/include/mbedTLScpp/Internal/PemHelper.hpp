// Copyright (c) 2022 mbedTLScpp
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

#pragma once


#include <cstddef>
#include <cstdint>

#include <mbedtls/pem.h>

#include "../Container.hpp"


#ifndef MBEDTLSCPP_CUSTOMIZED_NAMESPACE
namespace mbedTLScpp
#else
namespace MBEDTLSCPP_CUSTOMIZED_NAMESPACE
#endif
{
namespace Internal
{


template<typename _T>
inline constexpr _T QuickCeil(_T x, _T y) noexcept
{
	return (x + y - 1) / y;
	// or: return ((x - 1) / y) + 1; // requires x > 0
}


/**
 * @brief Calculate the length of the string that is generated by encoding a byte string.
 *
 * @tparam _BinBlockSize The binary block size.
 * @tparam _EncBlockSize The encoding block size.
 * @tparam _HasPad       Does it has padding?
 * @param binarySize     The size of the byte string, in bytes.
 * @return constexpr size_t The calculation result.
 */
template<uint8_t _BinBlockSize, uint8_t _EncBlockSize, bool _HasPad>
inline constexpr size_t CodecEncodedSize(size_t binarySize) noexcept
{
	return _HasPad ?
		(
			QuickCeil(binarySize, static_cast<size_t>(_BinBlockSize)) *
			_EncBlockSize
		) :
		(
			QuickCeil(
				binarySize * _EncBlockSize,
				static_cast<size_t>(_BinBlockSize)
			)
		);
}


/**
 * @brief Calculate the length of the string that is generated by Base64-encoding a byte string.
 *
 * @tparam _HasPad   Does it has padding?
 * @param binarySize The size of the byte string, in bytes.
 * @return constexpr size_t The calculation result.
 */
template<bool _HasPad>
inline constexpr size_t Base64EncodedSize(size_t binarySize) noexcept
{
	return CodecEncodedSize<3, 4, _HasPad>(binarySize);
}


/**
 * @brief Calculate the length of the PEM string based on the size of the DER.
 *
 * @param derSize    The size of the DER.
 * @param headerSize The length of the PEM header.
 * @param footerSize The length of the PEM footer.
 * @return constexpr size_t The calculation result.
 */
inline constexpr size_t CalcPemBytes(size_t derSize, size_t headerSize, size_t footerSize)
{
	return headerSize +                        // Header size
		Base64EncodedSize<true>(derSize) +        // Base64 encoded size
		1 +                                    // Required by mbedtls_base64_encode
		(Base64EncodedSize<true>(derSize) / 64) + //'\n' for each line
		footerSize +                           // Footer size
		1;                                     // null terminator
}


template<
	typename _PemContainerType,
	typename _DerCtnType,
	bool _DerCtnSecrecy,
	typename _HeaderContainerType,
	typename _FooterContainerType
>
inline _PemContainerType DerToPem(
	const ContCtnReadOnlyRef<_DerCtnType, _DerCtnSecrecy>& der,
	const _HeaderContainerType& header,
	const _FooterContainerType& footer
)
{
	size_t pemLen = Internal::CalcPemBytes(
		der.GetRegionSize(),
		header.size() - 1,
		footer.size() - 1
	);
	_PemContainerType pem(pemLen, '\0');

	size_t olen = 0;

	MBEDTLSCPP_MAKE_C_FUNC_CALL(
		Internal::DerToPem,
		mbedtls_pem_write_buffer,
		header.data(),
		footer.data(),
		der.BeginBytePtr(),
		der.GetRegionSize(),
		reinterpret_cast<unsigned char*>(&pem[0]),
		pem.size(),
		&olen
	);

	pem.resize(olen);

	for (; pem.size() > 0 && pem.back() == '\0'; pem.pop_back());

	return pem;
}

} // namespace Internal
} // namespace mbedTLScpp
